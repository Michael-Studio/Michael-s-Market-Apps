<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöó –î–ò–ö–ê–Ø –û–•–û–¢–ê: –£–º–Ω—ã–µ –∂–∏–≤–æ—Ç–Ω—ã–µ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
            pointer-events: none;
        }
        
        .panel {
            background: rgba(20, 20, 20, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #d4a76a;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7);
            font-size: 22px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            color: #ffaa00;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,170,0,0.5);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid rgba(255, 0, 0, 0.8);
            box-shadow: 0 0 20px red;
            z-index: 50;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 0, 0, 0.8);
        }
        
        #crosshair::before {
            width: 20px;
            height: 3px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #crosshair::after {
            width: 3px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #ammo {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px 40px;
            border-radius: 10px;
            border: 3px solid #ffaa00;
            font-size: 36px;
            font-weight: bold;
            color: #ffaa00;
            z-index: 100;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.9);
            color: #d4a76a;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 2px solid #ffaa00;
            font-family: 'Courier New', monospace;
        }
        
        #controls kbd {
            background: #8b5a2b;
            color: white;
            padding: 5px 12px;
            border-radius: 5px;
            margin: 0 5px;
            border: 1px solid #ffaa00;
        }
        
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 5px solid rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            z-index: 200;
            display: none;
            animation: hitPulse 0.3s ease-out;
        }
        
        @keyframes hitPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #e74c3c;
            padding: 60px 100px;
            border-radius: 20px;
            font-size: 72px;
            font-weight: bold;
            z-index: 300;
            display: none;
            border: 6px solid #c0392b;
            text-align: center;
            text-transform: uppercase;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            font-family: 'Impact', fantasy;
            letter-spacing: 4px;
        }
        
        #game-over span {
            font-size: 36px;
            color: #ecf0f1;
            display: block;
            margin-top: 20px;
        }
        
        #scope-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.9) 100%);
            z-index: 40;
            pointer-events: none;
        }
        
        #animal-counter {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffaa00;
            padding: 10px 30px;
            border-radius: 30px;
            font-size: 20px;
            z-index: 100;
            border: 2px solid #d4a76a;
            white-space: nowrap;
        }
        
        #car-status {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #4caf50;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 100;
            border: 2px solid #4caf50;
        }
        
        #animal-behavior {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #ffaa00;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            border: 1px solid #ffaa00;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="panel">üöó –î–ò–ö–ê–Ø –û–•–û–¢–ê: –£–ú–ù–´–ï –ñ–ò–í–û–¢–ù–´–ï</div>
        <div class="panel" id="score">üèÜ –°–ß–ï–¢: 0/30</div>
    </div>
    
    <div id="crosshair"></div>
    <div id="scope-overlay"></div>
    <div id="hit-marker"></div>
    
    <div id="ammo">
        üî´ <span id="bullets">5</span>/5
    </div>
    
    <div id="controls">
        <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> ‚Äî —Ö–æ–¥–∏—Ç—å |
        <kbd>üñ±Ô∏è –õ–ö–ú</kbd> ‚Äî —Å—Ç—Ä–µ–ª—è—Ç—å |
        <kbd>R</kbd> ‚Äî –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ |
        <kbd>F</kbd> ‚Äî —Å–µ—Å—Ç—å/–≤—ã–π—Ç–∏ –∏–∑ –º–∞—à–∏–Ω—ã
    </div>
    
    <div id="animal-counter">
        ü¶å –ñ–∏–≤–æ—Ç–Ω—ã—Ö –≤ –ª–µ—Å—É: <span id="animal-count">0</span>
    </div>
    
    <div id="car-status">
        üöó –ú–∞—à–∏–Ω–∞: <span id="in-car">–ù–ï–¢</span>
    </div>
    
    <div id="animal-behavior">
        üß† –ñ–∏–≤–æ—Ç–Ω—ã–µ —É–±–µ–≥–∞—é—Ç –æ—Ç –≤—ã—Å—Ç—Ä–µ–ª–æ–≤ –∏ –ø—Ä—è—á—É—Ç—Å—è –∑–∞ –¥–µ—Ä–µ–≤—å—è
    </div>
    
    <div id="game-over">
        üèÜ –í–ï–õ–ò–ö–ò–ô –û–•–û–¢–ù–ò–ö!
        <span>–í—Å–µ —Ç—Ä–æ—Ñ–µ–∏ —Å–æ–±—Ä–∞–Ω—ã</span>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ---
        const gameState = {
            score: 0,
            targetScore: 30,
            bullets: 5,
            maxBullets: 5,
            reloading: false,
            gameActive: true,
            animals: [],
            trees: [],
            inCar: false,
            car: null,
            lastShot: 0
        };

        // --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ü–µ–Ω—ã ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a2a2a);
        
        // --- –ö–∞–º–µ—Ä–∞ ---
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 0);
        
        // --- –†–µ–Ω–¥–µ—Ä–µ—Ä ---
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- –û—Å–≤–µ—â–µ–Ω–∏–µ ---
        const sunLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        sunLight.position.set(20, 30, 10);
        sunLight.castShadow = true;
        sunLight.receiveShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 60;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x405060);
        scene.add(ambientLight);

        // –¢—É–º–∞–Ω
        scene.fog = new THREE.Fog(0x0a2a2a, 30, 80);

        // --- –û–ì–†–û–ú–ù–´–ô –õ–ï–° (1500 –¥–µ—Ä–µ–≤—å–µ–≤) ---
        function createTree(x, z, size = 1.0) {
            const group = new THREE.Group();
            
            // –°—Ç–≤–æ–ª —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π –∫–æ—Ä—ã
            const trunkMat = new THREE.MeshStandardMaterial({ 
                color: 0x5d3a1a,
                roughness: 0.9,
                emissive: 0x000000
            });
            
            // –ù–µ—Ä–æ–≤–Ω—ã–π —Å—Ç–≤–æ–ª
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.6 * size, 0.9 * size, 4 * size, 8), trunkMat);
            trunk.position.y = 2 * size;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            group.add(trunk);
            
            // –í–µ—Ç–∫–∏
            const branchMat = new THREE.MeshStandardMaterial({ color: 0x4a2c1a });
            for (let i = 0; i < 3; i++) {
                const branch = new THREE.Mesh(new THREE.ConeGeometry(0.3 * size, 1.0 * size, 4), branchMat);
                branch.position.set(0.5 * size, (2 + i) * size, 0.3 * size);
                branch.rotation.z = 0.3;
                branch.castShadow = true;
                group.add(branch);
            }
            
            // –õ–∏—Å—Ç–≤–∞ (–µ–ª—å) - –ø—É—à–∏—Å—Ç–∞—è
            const leafMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a4d1a,
                emissive: 0x0a2a0a,
                roughness: 0.7
            });
            
            for (let i = 0; i < 5; i++) {
                const leaf = new THREE.Mesh(
                    new THREE.ConeGeometry(1.3 * size * (1 - i*0.1), 1.8 * size, 8),
                    leafMat
                );
                leaf.position.y = (3 + i * 1.0) * size;
                leaf.castShadow = true;
                leaf.receiveShadow = true;
                group.add(leaf);
            }
            
            group.position.set(x, 0, z);
            group.userData = {
                type: 'tree',
                radius: 1.8 * size,
                position: new THREE.Vector3(x, 0, z)
            };
            
            return group;
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ª–µ—Å
        for (let i = 0; i < 1500; i++) {
            const x = (Math.random() - 0.5) * 250;
            const z = (Math.random() - 0.5) * 250;
            
            if (Math.abs(x) < 20 && Math.abs(z) < 20) continue;
            
            const size = 0.6 + Math.random() * 1.0;
            const tree = createTree(x, z, size);
            scene.add(tree);
            gameState.trees.push(tree);
        }

        // –¢—Ä–∞–≤–∞ —Å –¥–µ—Ç–∞–ª—è–º–∏
        const grassGeom = new THREE.PlaneGeometry(300, 300);
        const grassMat = new THREE.MeshStandardMaterial({ 
            color: 0x2d4b1e,
            roughness: 1.0,
            emissive: 0x111111
        });
        const grass = new THREE.Mesh(grassGeom, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = 0;
        grass.receiveShadow = true;
        scene.add(grass);

        // --- –í–ê–ó-2107 (—É–ª—É—á—à–µ–Ω–Ω—ã–π) ---
        function createVAZ2107() {
            const car = new THREE.Group();
            
            // –ö—É–∑–æ–≤ —Å –±–ª–µ—Å–∫–æ–º
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513, 
                roughness: 0.3, 
                metalness: 0.4,
                emissive: 0x221100
            });
            
            // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.2, 4.5), bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            body.receiveShadow = true;
            car.add(body);
            
            // –ö—Ä—ã—à–∞ —Å–æ —Å–ø–æ–π–ª–µ—Ä–æ–º
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.5 });
            const roof = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 2.0), roofMat);
            roof.position.set(0, 1.3, -0.3);
            roof.castShadow = true;
            car.add(roof);
            
            // –ö–∞–ø–æ—Ç
            const hood = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.3, 1.2), roofMat);
            hood.position.set(0, 0.9, 1.3);
            hood.castShadow = true;
            car.add(hood);
            
            // –§–∞—Ä—ã (—Å–≤–µ—Ç—è—â–∏–µ—Å—è)
            const lightMat = new THREE.MeshStandardMaterial({ 
                color: 0xffdd99, 
                emissive: 0x442200,
                transparent: true,
                opacity: 0.9
            });
            
            const headlightL = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.15, 12), lightMat);
            headlightL.rotation.z = Math.PI/2;
            headlightL.position.set(-0.9, 0.8, 2.1);
            car.add(headlightL);
            
            const headlightR = headlightL.clone();
            headlightR.position.set(0.9, 0.8, 2.1);
            car.add(headlightR);
            
            // –†–µ—à–µ—Ç–∫–∞ —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞
            const grillMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });
            const grill = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.3, 0.1), grillMat);
            grill.position.set(0, 0.7, 2.2);
            car.add(grill);
            
            // –°—Ç–µ–∫–ª–∞ —Å –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ–º
            const glassMat = new THREE.MeshStandardMaterial({ 
                color: 0x88aaff, 
                transparent: true, 
                opacity: 0.3,
                metalness: 0.9,
                roughness: 0.1
            });
            
            const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.7, 0.1), glassMat);
            windshield.position.set(0, 1.2, 1.0);
            windshield.rotation.x = 0.2;
            car.add(windshield);
            
            // –ö–æ–ª–µ—Å–∞ —Å –¥–∏—Å–∫–∞–º–∏
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });
            
            const wheelPositions = [
                [-1.0, 0.3, 1.2],
                [1.0, 0.3, 1.2],
                [-1.0, 0.3, -1.4],
                [1.0, 0.3, -1.4]
            ];
            
            wheelPositions.forEach(pos => {
                const wheelGroup = new THREE.Group();
                
                const tire = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.3, 24), wheelMat);
                tire.rotation.z = Math.PI/2;
                tire.castShadow = true;
                wheelGroup.add(tire);
                
                const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.31, 8), rimMat);
                rim.rotation.z = Math.PI/2;
                rim.castShadow = true;
                wheelGroup.add(rim);
                
                wheelGroup.position.set(pos[0], pos[1], pos[2]);
                car.add(wheelGroup);
            });
            
            car.position.set(5, 0, 5);
            car.userData = {
                type: 'car',
                radius: 2.5
            };
            
            return car;
        }

        const car = createVAZ2107();
        scene.add(car);
        gameState.car = car;

        // --- –£–õ–£–ß–®–ï–ù–ù–´–ï –ñ–ò–í–û–¢–ù–´–ï ---
        
        // –ö–∞–±–∞–Ω (–±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω—ã–π)
        function createBoar() {
            const group = new THREE.Group();
            
            // –¢–µ–ª–æ —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π —â–µ—Ç–∏–Ω—ã
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4a3c2c, roughness: 0.8 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.9, 1.5, 8), bodyMat);
            body.position.y = 0.7;
            body.scale.set(1.2, 0.8, 0.9);
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // –ì–æ–ª–æ–≤–∞ —Å –¥–µ—Ç–∞–ª—è–º–∏
            const headMat = new THREE.MeshStandardMaterial({ color: 0x3d2e1e });
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8), headMat);
            head.position.set(0.9, 0.7, 0);
            head.scale.set(0.8, 0.7, 0.7);
            head.castShadow = true;
            group.add(head);
            
            // –ü—è—Ç–∞–∫
            const snout = new THREE.Mesh(new THREE.SphereGeometry(0.2, 6), new THREE.MeshStandardMaterial({ color: 0x5a4a3a }));
            snout.position.set(1.2, 0.65, 0);
            group.add(snout);
            
            // –ö–ª—ã–∫–∏
            const tuskMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const tusk = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 5), tuskMat);
            tusk.position.set(1.3, 0.6, 0.2);
            tusk.rotation.z = 0.2;
            group.add(tusk);
            
            const tusk2 = tusk.clone();
            tusk2.position.set(1.3, 0.6, -0.2);
            tusk2.rotation.z = -0.2;
            group.add(tusk2);
            
            // –ì–ª–∞–∑–∞ —Å –±–ª–∏–∫–∞–º–∏
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.1, 5), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.08, 5), eyeMat);
            eyeL.position.set(1.0, 0.85, 0.25);
            group.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.set(1.0, 0.85, -0.25);
            group.add(eyeR);
            
            // –£—à–∏
            const earMat = new THREE.MeshStandardMaterial({ color: 0x4a3c2c });
            const ear = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 5), earMat);
            ear.position.set(0.7, 1.0, 0.35);
            ear.rotation.x = -0.2;
            group.add(ear);
            
            const ear2 = ear.clone();
            ear2.position.set(0.7, 1.0, -0.35);
            ear2.rotation.x = 0.2;
            group.add(ear2);
            
            group.userData = {
                type: 'boar',
                speed: 0.045,
                health: 1,
                value: 1,
                radius: 1.2,
                fear: 0,
                lastSeenPlayer: null,
                hidingSpot: null
            };
            
            return group;
        }

        // –û–ª–µ–Ω—å (–±–ª–∞–≥–æ—Ä–æ–¥–Ω—ã–π)
        function createDeer() {
            const group = new THREE.Group();
            
            // –ò–∑—è—â–Ω–æ–µ —Ç–µ–ª–æ
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xc19a6b, roughness: 0.6 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.7, 1.4, 8), bodyMat);
            body.position.y = 0.7;
            body.scale.set(1.1, 0.9, 0.8);
            body.castShadow = true;
            group.add(body);
            
            // –®–µ—è
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.6, 6), bodyMat);
            neck.position.set(0.7, 1.1, 0);
            neck.rotation.x = 0.3;
            neck.castShadow = true;
            group.add(neck);
            
            // –ì–æ–ª–æ–≤–∞
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 6), new THREE.MeshStandardMaterial({ color: 0xb08968 }));
            head.position.set(1.1, 1.3, 0);
            head.castShadow = true;
            group.add(head);
            
            // –†–æ–≥–∞ (–≤–µ—Ç–≤–∏—Å—Ç—ã–µ)
            const hornMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
            
            for (let side = 0; side < 2; side++) {
                const sign = side === 0 ? 1 : -1;
                
                const hornBase = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.5, 5), hornMat);
                hornBase.position.set(1.2, 1.6, 0.2 * sign);
                hornBase.rotation.z = 0.2 * sign;
                group.add(hornBase);
                
                const hornTip = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.3, 5), hornMat);
                hornTip.position.set(1.35, 1.85, 0.3 * sign);
                hornTip.rotation.z = 0.3 * sign;
                group.add(hornTip);
            }
            
            // –ì–ª–∞–∑–∞
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 5), eyeMat);
            eyeL.position.set(1.2, 1.35, 0.15);
            group.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.set(1.2, 1.35, -0.15);
            group.add(eyeR);
            
            // –•–≤–æ—Å—Ç
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.2, 4), bodyMat);
            tail.position.set(-0.8, 0.8, 0);
            group.add(tail);
            
            group.userData = {
                type: 'deer',
                speed: 0.07,
                health: 1,
                value: 2,
                radius: 1.0,
                fear: 0,
                lastSeenPlayer: null,
                hidingSpot: null
            };
            
            return group;
        }

        // –í–æ–ª–∫ (—Ö–∏—â–Ω–∏–∫)
        function createWolf() {
            const group = new THREE.Group();
            
            // –ú—É—Å–∫—É–ª–∏—Å—Ç–æ–µ —Ç–µ–ª–æ
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x6d6d6d, roughness: 0.5 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.3, 8), bodyMat);
            body.position.y = 0.6;
            body.scale.set(1.0, 0.8, 0.8);
            body.castShadow = true;
            group.add(body);
            
            // –ì–æ–ª–æ–≤–∞ —Ö–∏—â–Ω–∏–∫–∞
            const headMat = new THREE.MeshStandardMaterial({ color: 0x5d5d5d });
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 6), headMat);
            head.position.set(0.8, 0.9, 0);
            head.castShadow = true;
            group.add(head);
            
            // –ú–æ—Ä–¥–∞
            const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.4, 5), headMat);
            snout.position.set(1.1, 0.9, 0);
            snout.rotation.x = 0.2;
            group.add(snout);
            
            // –£—à–∏
            const earMat = new THREE.MeshStandardMaterial({ color: 0x5d5d5d });
            const ear = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.3, 5), earMat);
            ear.position.set(0.7, 1.2, 0.2);
            ear.rotation.x = -0.3;
            group.add(ear);
            
            const ear2 = ear.clone();
            ear2.position.set(0.7, 1.2, -0.2);
            ear2.rotation.x = -0.3;
            group.add(ear2);
            
            // –ì–ª–∞–∑–∞ (—Ö–∏—â–Ω—ã–µ)
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.07, 5), eyeMat);
            eyeL.position.set(0.95, 1.0, 0.2);
            group.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.set(0.95, 1.0, -0.2);
            group.add(eyeR);
            
            // –•–≤–æ—Å—Ç
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.5, 5), bodyMat);
            tail.position.set(-0.7, 0.7, 0);
            tail.rotation.x = 0.3;
            group.add(tail);
            
            group.userData = {
                type: 'wolf',
                speed: 0.08,
                health: 1,
                value: 3,
                radius: 1.0,
                fear: 0,
                lastSeenPlayer: null,
                hidingSpot: null
            };
            
            return group;
        }

        // –õ–∏—Å–∞ (—Ö–∏—Ç—Ä–∞—è)
        function createFox() {
            const group = new THREE.Group();
            
            // –†—ã–∂–µ–µ —Ç–µ–ª–æ
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff8833, roughness: 0.7 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.0, 8), bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);
            
            // –ì–æ–ª–æ–≤–∞
            const headMat = new THREE.MeshStandardMaterial({ color: 0xff7733 });
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 6), headMat);
            head.position.set(0.6, 0.8, 0);
            head.castShadow = true;
            group.add(head);
            
            // –û—Å—Ç—Ä–∞—è –º–æ—Ä–¥–æ—á–∫–∞
            const snout = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.3, 5), headMat);
            snout.position.set(0.9, 0.8, 0);
            group.add(snout);
            
            // –£—à–∏ —Å —á–µ—Ä–Ω—ã–º–∏ –∫–æ–Ω—á–∏–∫–∞–º–∏
            const earMat = new THREE.MeshStandardMaterial({ color: 0xff7733 });
            const earTipMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const ear = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.3, 5), earMat);
            ear.position.set(0.5, 1.1, 0.15);
            ear.rotation.x = -0.2;
            group.add(ear);
            
            const earTip = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.1, 4), earTipMat);
            earTip.position.set(0.5, 1.2, 0.15);
            group.add(earTip);
            
            const ear2 = ear.clone();
            ear2.position.set(0.5, 1.1, -0.15);
            group.add(ear2);
            
            const earTip2 = earTip.clone();
            earTip2.position.set(0.5, 1.2, -0.15);
            group.add(earTip2);
            
            // –ü—É—à–∏—Å—Ç—ã–π —Ö–≤–æ—Å—Ç
            const tailMat = new THREE.MeshStandardMaterial({ color: 0xff9933 });
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.7, 6), tailMat);
            tail.position.set(-0.7, 0.5, 0);
            tail.rotation.x = 0.4;
            tail.rotation.z = 0.2;
            tail.castShadow = true;
            group.add(tail);
            
            // –ì–ª–∞–∑–∞ (—Ö–∏—Ç—Ä—ã–µ)
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 5), eyeMat);
            eyeL.position.set(0.7, 0.9, 0.15);
            group.add(eyeL);
            
            const eyeR = eyeL.clone();
            eyeR.position.set(0.7, 0.9, -0.15);
            group.add(eyeR);
            
            group.userData = {
                type: 'fox',
                speed: 0.06,
                health: 1,
                value: 1,
                radius: 0.9,
                fear: 0,
                lastSeenPlayer: null,
                hidingSpot: null
            };
            
            return group;
        }

        // --- –°–û–ó–î–ê–ï–ú 50 –£–ú–ù–´–• –ñ–ò–í–û–¢–ù–´–• ---
        const animalTypes = [createBoar, createDeer, createWolf, createFox];
        
        for (let i = 0; i < 50; i++) {
            const type = Math.floor(Math.random() * animalTypes.length);
            const animal = animalTypes[type]();
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 80;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            animal.position.set(x, 0, z);
            animal.userData.direction = Math.random() * Math.PI * 2;
            animal.userData.id = i;
            animal.userData.state = 'wandering'; // wandering, fleeing, hiding
            animal.userData.fear = 0;
            
            scene.add(animal);
            gameState.animals.push(animal);
        }

        // --- –í–∏–Ω—Ç–æ–≤–∫–∞ ---
        const rifleGroup = new THREE.Group();
        
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8),
            new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 })
        );
        barrel.rotation.z = Math.PI / 2;
        barrel.position.set(0.4, -0.1, -0.4);
        barrel.castShadow = true;
        rifleGroup.add(barrel);
        
        const stock = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.15, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        stock.position.set(-0.3, -0.1, -0.4);
        stock.castShadow = true;
        rifleGroup.add(stock);
        
        const scope = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.5 })
        );
        scope.rotation.z = Math.PI / 2;
        scope.position.set(0.1, 0.12, -0.4);
        rifleGroup.add(scope);
        
        rifleGroup.position.set(0.3, -0.2, -0.5);
        camera.add(rifleGroup);
        scene.add(camera);

        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
        const keyState = { w: false, a: false, s: false, d: false, f: false };
        const mouseSensitivity = 0.002;
        let pitch = 0;
        let yaw = 0;
        
        document.addEventListener('mousemove', (e) => {
            if (!gameState.gameActive) return;
            if (document.pointerLockElement !== renderer.domElement) return;
            
            yaw -= e.movementX * mouseSensitivity;
            pitch -= e.movementY * mouseSensitivity;
            
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        });
        
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });
        
        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keyState.w = true; e.preventDefault(); break;
                case 'KeyA': keyState.a = true; e.preventDefault(); break;
                case 'KeyS': keyState.s = true; e.preventDefault(); break;
                case 'KeyD': keyState.d = true; e.preventDefault(); break;
                case 'KeyF': 
                    keyState.f = true; 
                    toggleCar();
                    e.preventDefault(); 
                    break;
                case 'KeyR': 
                    reload(); 
                    e.preventDefault(); 
                    break;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keyState.w = false; e.preventDefault(); break;
                case 'KeyA': keyState.a = false; e.preventDefault(); break;
                case 'KeyS': keyState.s = false; e.preventDefault(); break;
                case 'KeyD': keyState.d = false; e.preventDefault(); break;
            }
        });

        // --- –§—É–Ω–∫—Ü–∏–∏ –∏–≥—Ä—ã ---
        function toggleCar() {
            const dist = camera.position.distanceTo(car.position);
            if (dist < 5) {
                gameState.inCar = !gameState.inCar;
                document.getElementById('in-car').innerHTML = gameState.inCar ? '–î–ê' : '–ù–ï–¢';
                
                if (gameState.inCar) {
                    camera.position.copy(car.position.clone().add(new THREE.Vector3(0, 1.5, 2)));
                }
            }
        }

        function shoot() {
            if (!gameState.gameActive || gameState.reloading) return;
            if (gameState.bullets <= 0) {
                alert('–ù–µ—Ç –ø–∞—Ç—Ä–æ–Ω–æ–≤! –ù–∞–∂–º–∏ R');
                return;
            }
            
            gameState.bullets--;
            updateAmmo();
            gameState.lastShot = Date.now();
            
            // –ó–≤—É–∫ –≤—ã—Å—Ç—Ä–µ–ª–∞ (–≤–∏–∑—É–∞–ª—å–Ω–æ - –≤—Å–µ –∂–∏–≤–æ—Ç–Ω—ã–µ –ø—É–≥–∞—é—Ç—Å—è)
            gameState.animals.forEach(animal => {
                const dist = camera.position.distanceTo(animal.position);
                if (dist < 30) {
                    animal.userData.fear = Math.min(1, animal.userData.fear + 0.5);
                    animal.userData.lastSeenPlayer = camera.position.clone();
                }
            });
            
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.copy(camera.position);
            raycaster.ray.direction.set(0, 0, -1).applyEuler(camera.rotation);
            
            const intersects = raycaster.intersectObjects(gameState.animals, true);
            
            if (intersects.length > 0) {
                const hitAnimal = intersects[0].object.parent;
                
                document.getElementById('hit-marker').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('hit-marker').style.display = 'none';
                }, 200);
                
                scene.remove(hitAnimal);
                const index = gameState.animals.indexOf(hitAnimal);
                if (index > -1) {
                    gameState.animals.splice(index, 1);
                    gameState.score += hitAnimal.userData.value;
                    document.getElementById('score').innerHTML = `üèÜ –°–ß–ï–¢: ${gameState.score}/${gameState.targetScore}`;
                }
                
                if (gameState.score >= gameState.targetScore) {
                    gameState.gameActive = false;
                    document.getElementById('game-over').style.display = 'block';
                    document.exitPointerLock();
                }
            }
        }

        function reload() {
            if (gameState.reloading) return;
            
            gameState.reloading = true;
            setTimeout(() => {
                gameState.bullets = gameState.maxBullets;
                gameState.reloading = false;
                updateAmmo();
            }, 1500);
        }

        function updateAmmo() {
            document.getElementById('bullets').innerHTML = gameState.bullets;
        }

        // --- –£–ú–ù–û–ï –ü–û–í–ï–î–ï–ù–ò–ï –ñ–ò–í–û–¢–ù–´–• ---
        function updateAnimalAI() {
            const playerPos = camera.position.clone();
            
            gameState.animals.forEach(animal => {
                const distToPlayer = animal.position.distanceTo(playerPos);
                
                // –°—Ç—Ä–∞—Ö —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                animal.userData.fear = Math.max(0, animal.userData.fear - 0.002);
                
                // –†–µ–∞–∫—Ü–∏—è –Ω–∞ –±–ª–∏–∑–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞
                if (distToPlayer < 20) {
                    animal.userData.fear += 0.01;
                    animal.userData.lastSeenPlayer = playerPos.clone();
                }
                
                // –ü–æ–∏—Å–∫ —É–∫—Ä—ã—Ç–∏—è –∑–∞ –¥–µ—Ä–µ–≤—å—è–º–∏
                if (animal.userData.fear > 0.3 && !animal.userData.hidingSpot) {
                    // –ò—â–µ–º –±–ª–∏–∂–∞–π—à–µ–µ –¥–µ—Ä–µ–≤–æ
                    let closestTree = null;
                    let closestDist = Infinity;
                    
                    gameState.trees.forEach(tree => {
                        const dist = animal.position.distanceTo(tree.position);
                        if (dist < 10 && dist < closestDist) {
                            closestDist = dist;
                            closestTree = tree;
                        }
                    });
                    
                    if (closestTree) {
                        animal.userData.hidingSpot = closestTree.position.clone();
                        animal.userData.state = 'hiding';
                    }
                }
                
                // –ü–æ–≤–µ–¥–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
                if (animal.userData.fear > 0.5) {
                    // –£–±–µ–≥–∞–µ—Ç –æ—Ç –∏–≥—Ä–æ–∫–∞
                    const awayDir = animal.position.clone().sub(playerPos).normalize();
                    animal.userData.direction = Math.atan2(awayDir.x, awayDir.z);
                    animal.userData.state = 'fleeing';
                } 
                else if (animal.userData.hidingSpot) {
                    // –ò–¥–µ—Ç –∫ —É–∫—Ä—ã—Ç–∏—é
                    const toHiding = animal.userData.hidingSpot.clone().sub(animal.position).normalize();
                    animal.userData.direction = Math.atan2(toHiding.x, toHiding.z);
                    
                    // –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥ —É–∫—Ä—ã—Ç–∏—è
                    if (animal.position.distanceTo(animal.userData.hidingSpot) < 2) {
                        animal.userData.hidingSpot = null;
                        animal.userData.state = 'wandering';
                        animal.userData.fear = 0;
                    }
                }
                else {
                    // –°–ª—É—á–∞–π–Ω–æ–µ –±–ª—É–∂–¥–∞–Ω–∏–µ
                    if (Math.random() < 0.005) {
                        animal.userData.direction += (Math.random() - 0.5) * 0.5;
                    }
                    animal.userData.state = 'wandering';
                }
                
                // –î–≤–∏–∂–µ–Ω–∏–µ
                const speed = animal.userData.speed * (animal.userData.fear > 0.5 ? 1.5 : 1);
                const moveX = Math.sin(animal.userData.direction) * speed;
                const moveZ = Math.cos(animal.userData.direction) * speed;
                
                const newX = animal.position.x + moveX;
                const newZ = animal.position.z + moveZ;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –¥–µ—Ä–µ–≤—å—è–º–∏
                let canMove = true;
                for (let tree of gameState.trees) {
                    const dist = Math.sqrt(
                        (newX - tree.position.x)**2 + 
                        (newZ - tree.position.z)**2
                    );
                    if (dist < 2.5) {
                        canMove = false;
                        // –û–≥–∏–±–∞–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤
                        animal.userData.direction += (Math.random() - 0.5) * 0.3;
                        break;
                    }
                }
                
                if (canMove) {
                    animal.position.x = newX;
                    animal.position.z = newZ;
                }
                
                // –ü–ª–∞–≤–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                const targetRot = animal.userData.direction;
                let rotDiff = targetRot - animal.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                animal.rotation.y += rotDiff * 0.1;
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –¥—ã—Ö–∞–Ω–∏—è/–±–µ–≥–∞
                animal.position.y = Math.sin(Date.now() * 0.005 + animal.userData.id) * 0.05;
            });
            
            document.getElementById('animal-count').innerHTML = gameState.animals.length;
        }

        // --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –¥–µ—Ä–µ–≤—å—è–º–∏ –¥–ª—è –∏–≥—Ä–æ–∫–∞ ---
        function checkTreeCollision(position) {
            for (let tree of gameState.trees) {
                const dx = position.x - tree.position.x;
                const dz = position.z - tree.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                
                if (dist < 2.0) {
                    return true;
                }
            }
            return false;
        }

        // --- –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ ---
        function movePlayer() {
            const speed = gameState.inCar ? 0.4 : 0.15;
            
            const forward = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
            const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
            
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();
            
            let moveX = 0, moveZ = 0;
            
            if (keyState.w) {
                moveX += forward.x * speed;
                moveZ += forward.z * speed;
            }
            if (keyState.s) {
                moveX -= forward.x * speed;
                moveZ -= forward.z * speed;
            }
            if (keyState.a) {
                moveX -= right.x * speed;
                moveZ -= right.z * speed;
            }
            if (keyState.d) {
                moveX += right.x * speed;
                moveZ += right.z * speed;
            }
            
            if (moveX !== 0 || moveZ !== 0) {
                const newPos = camera.position.clone();
                newPos.x += moveX;
                newPos.z += moveZ;
                
                if (!checkTreeCollision(newPos)) {
                    camera.position.x = newPos.x;
                    camera.position.z = newPos.z;
                }
                
                if (gameState.inCar) {
                    car.position.x = camera.position.x;
                    car.position.z = camera.position.z;
                    car.rotation.y = yaw;
                }
            }
        }

        // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã—Å—Ç—Ä–µ–ª–∞ ---
        renderer.domElement.addEventListener('click', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                shoot();
            }
        });

        // --- –ê–Ω–∏–º–∞—Ü–∏—è ---
        function animate() {
            requestAnimationFrame(animate);

            if (gameState.gameActive) {
                movePlayer();
                updateAnimalAI();
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateAmmo();
        document.getElementById('animal-count').innerHTML = gameState.animals.length;
    </script>
</body>
</html>